"""
Задание 1.
Реализуйте свои пользовательские функции, в которых реализуйте:
a) заполнение списка и словаря,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему
Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!
Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
"""

# Я перепробовал всё. Менял длину списков и словарей, менял индекс/ключ, по которому идёт удаление/поиск,
# передавал списки/словари параметром в функцию, чтобы не создавать их внутри,
# потратил кучу времени, но результаты всё равно
# противоположенные ожиданиям. Поэтому объяснить почему так происходит я не могу, но все все операции
# (из тех которые я использовал естественно) кроме заполнения выполняются быстрее со списком.
# Заполнение наоборот происходит быстрее у словарей, хотя должно быть наоборот.
# Если бы в этом ДЗ можно было не делать одно задание, именно это я бы не сдал, потому что оно очевидно провалено.
# Задание считаю ужасным, хотелось бы надеяться, что таких дальше не будет.


from time import perf_counter


def time_measure(func):
    def measure():
        start = perf_counter()
        for _ in range(1000000):
            func()
        end = perf_counter()
        print(f'{func} - {end - start}')
    return measure


@time_measure
def fulfill_lst():
    lst = []
    for i in range(10):
        lst.append(i)


@time_measure
def fulfill_dct():
    dct = {}
    for i in range(10):
        dct[i] = i


@time_measure
def delete_lst():
    lst = [1, 2, 3, 4]
    lst.remove(1)


@time_measure
def delete_dct():
    dct = {1: 1, 2: 2, 3: 3, 4: 4}
    del dct[1]


@time_measure
def get_lst():
    lst = [1, 2, 3, 4]
    return lst[3]


@time_measure
def get_dct():
    dct = {1: 1, 2: 2, 3: 3, 4: 4}
    return dct[3]


@time_measure
def pop_lst():
    lst = [1, 2, 3, 4]
    return lst.pop()


@time_measure
def pop_dct():
    dct = {1: 1, 2: 2, 3: 3, 4: 4}
    return dct.pop(2)


@time_measure
def search_lst():
    lst = [1, 2, 3, 4]
    return 3 in lst


@time_measure
def search_dct():
    dct = {1: 1, 2: 2, 3: 3, 4: 4}
    return 3 in dct


fulfill_lst()
fulfill_dct()
delete_lst()
delete_dct()
get_lst()
get_dct()
pop_lst()
pop_dct()
search_lst()
search_dct()