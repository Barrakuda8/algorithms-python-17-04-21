"""
Задание 5.**
Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).
Попробуйте решить эту же задачу,
применив алгоритм "Решето Эратосфена" (https://younglinux.info/algorithm/sieve)
Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма.
Укажите формулу сложности О-нотация каждого алгоритма
и сделайте обоснование результатам.
"""

# Сложность обоих алгоритмов - O(n^2)
# Но суть в том, что при одинаковом первом линейном множителе (n - количество чисел с 2 до искомого простого числа),
# второй линейный множитель абсолютно разный. В первом варианте это количество всех чисел до числа,
# перебираемого в данный момент, а во втором это количество простых чисел до этого числа, что в разы меньше.
# Именно поэтому новый алгоритм выполняется в разы быстрее старого.


from timeit import timeit


def simple(i):  # n * (const * n + const) => O(n^2)
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


def eratosfen(i):  # n * (const * n + const) => O(n^2)
    simples = []
    n = 2
    while len(simples) < i:
        is_simple = True
        for j in simples:
            if n % j == 0:
                is_simple = False
                break
        if is_simple:
            simples.append(n)
        n += 1
    return simples[-1]


i = int(input('Введите порядковый номер искомого простого числа: '))
print(simple(i))
print(eratosfen(i))
print(timeit(f'simple({i})', globals=globals()))
print(timeit(f'eratosfen({i})', globals=globals()))