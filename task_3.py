"""
Задание 3.

Для этой задачи:
1) придумайте 2-3 решения (не менее двух)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.

Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""

# В задании не указано, что делать, если у двух компаний одинаковая годовая прибыль и это влияет на результат.
# Поэтому в этом случае в результат попадает случайная(ые) компания(ии) из подобных, если все попасть не могут.

def max3_1(dct):  # O(n log n) <= nlogn + 3
    return sorted(dct, key=dct.get)[-3:]


def max3_2(dct):  # O(n log n) <= c + n + nlogn + 3
    lst = list(dct.items())
    lst.sort(key=lambda i: i[1])
    return lst[-3:]


def max3_3(dct):  # O(n) - много кода, но только в одном месте линейная сложность, а в остальных константные
    result = []  # O(1)
    min_result = []  # O(1)

    def min_res_func(mr):
        for i in result:  # O(1) ибо длина result всегда 3
            if i[1] < mr[1]:   # O(1)
                mr = i  # O(1)
        return mr  # O(1)

    for key, value in dct.items():  # O(n)
        if len(result) < 3:  # O(1)
            result.append([key, value])   # O(1)
            if len(result) == 3:   # O(1)
                min_result = result[0]  # O(1)
                min_result = min_res_func(min_result)  # O(1) - ибо длина result всегда 3
        else:   # O(1)
            if value > min_result[1]:   # O(1)
                result.remove(min_result)  # O(1) - ибо длина result всегда 3
                result.append([key, value])  # O(1)
                min_result = min_res_func(result[0])  # O(1) - ибо длина result всегда 3
    return result  # O(1)


'''
Вывод - третий вариант имеет наименьшую сложность, однако наибольший размер кода.
Так что я бы сказал, что первые два варианта эффективнее при небольшом количестве компаний, а третий - при большом.
'''

companies = {'A': 12000, 'B': 1000, 'C': 2600, 'D': 15000, 'E': 10000}

print(max3_1(companies))
print(max3_2(companies))
print(max3_3(companies))